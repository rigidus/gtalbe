#+STARTUP: showall indent hidestars

Чтобы запустить проект и проверить решение тестового задания переходите к разделу

* Задача:

Разработать и реализовать на языке Go небольшой внутренний RESTful API, который продемонстрирует следующие возможности:

** Конечные точки API / схема

Обеспечить конечные точки для:
- *Запрос баланса кошелька*
  Учитывая адрес 0x, получить и вернуть текущий баланс $FIL и iFIL этого кошелька.
- *Отправки транзакции*
  Позволить клиенту API отправить новую транзакцию для перевода FIL с одного кошелька на другой на блокчейне Filecoin (FEVM). Для этого необходимо принять необходимые данные (такие как отправитель, получатель, сумма и т. д.), отправить транзакцию на узел или сервис Filecoin и вернуть хэш транзакции или квитанцию.
- *Сохранения данных транзакции*
  При отправке транзакции сохраняйте ее данные в базе данных PostgreSQL. Как минимум, записывайте такие поля, как хэш транзакции, адрес отправителя, адрес получателя, сумма, временная метка и статус (ожидание/подтверждение/отказ).
- *Получения транзакций*
  Обеспечьте способ получения записей о транзакциях из базы данных (например, конечную точку для вывода списка всех транзакций или фильтрации по счету). Это должно продемонстрировать эффективный запрос (например, возможность получить все транзакции для заданного адреса). Обратите внимание, что вам не нужно беспокоиться о транзакциях, которые произошли вне контекста данного бэкэнд-сервиса.

** Управление базой данных

Используйте PostgreSQL для хранения и управления данными о транзакциях. Разработайте простую схему для хранения транзакций и реализуйте операции создания/чтения. Убедитесь, что данные индексируются или запрашиваются эффективно (например, для получения транзакций по определенному адресу не должно требоваться сканирование всей таблицы).

** Качество кода

Следуйте лучшим практикам Go для структуры проекта и стиля кода. Код должен быть ремонтопригодным и масштабируемым - это означает, что он должен быть организован в логические пакеты или слои (например, разделение обработчиков API, клиентской логики блокчейна и доступа к базе данных). Включите соответствующую обработку ошибок и ведение журнала.

Стремитесь к ясности и надежности, как если бы это был код производственного качества.

* Инструкции:

- Разработайте API в соответствии с лучшими практиками (например, для REST используйте правильные методы HTTP и коды состояния).
- Для взаимодействия с блокчейном вы можете использовать GLIF Pools SDK, в который встроена поддержка узлов Filecoin. Вы также можете использовать существующие библиотеки Go (например, официальный Go Ethereum SDK go-ethereum для вызовов JSON-RPC) или вызвать публичный API. Важно: Не раскрывайте реальные приватные ключи в своем коде.
- Подготовьте базу данных PostgreSQL таким образом, чтобы мы могли легко ее настроить. Вы можете включить скрипт миграции SQL или использовать ORM (например, GORM), чтобы программно создать схему. Убедитесь, что ваш код знает, как подключиться к базе данных (например, через строку подключения или переменные окружения). Если вы используете ORM или необработанный SQL, обязательно параметризуйте запросы, чтобы предотвратить SQL-инъекции.
- Как минимум один тест не обязателен, но рекомендуется.

* Предоставляемые материалы:

Предоставьте исходный код и README. README должен содержать:

- Инструкции по созданию и запуску сервиса, включая все необходимые настройки (например, установка переменных окружения для строки подключения к БД, URL RPC блокчейна и т.д.)
- Примеры вызова API (примеры запросов и ожидаемых ответов).

Если для инициализации необходимы какие-либо дополнительные шаги (например, запуск миграции базы данных), четко опишите их. Если вы включили какие-либо тесты, укажите, как их запустить. Мы должны иметь возможность запустить ваш проект локально и протестировать конечные точки. По желанию вы можете включить Dockerfile или docker-compose setup, чтобы упростить запуск сервиса и базы данных, но это не обязательно.

Сосредоточьте свои усилия на выполнении основных требований - лучше иметь функциональную, чистую реализацию основных функций, чем неполную попытку реализовать множество дополнительных возможностей.

Вы можете упомянуть в README, какие улучшения вы бы реализовали, если бы у вас было больше времени (например, дополнительные конечные точки, лучшая обработка ошибок в некоторых областях и т.д.).

* Мои вопросы
** Что такое $FIL и iFIL?

$FIL — это нативный токен сети Filecoin, децентрализованной системы хранения данных, где пользователи могут арендовать пространство у поставщиков хранения. Токен используется для оплаты услуг хранения и обеспечения работы сети. Например, можно использовать $FIL для покупки места на серверах, распределенных по всему миру, для безопасного хранения данных.

iFIL — ERC20-токен на FEVM для начисления вознаграждений в GLIF (подробности: https://docs.glif.io/for-liquidity-providers/glif-reward-mechanism-ifil)

* Мои умолчания
*** Эндпоинты RESTful

- GET /balance/{address} - получение баланса кошелька ($FIL и iFIL) по адресу.
  Баланс возвращается в двух токенах ($FIL и iFIL). Для получения баланса iFIL я использую библиотеку, совместимую с Ethereum, вызывая balanceOf контракта iFIL, предполагая, что адрес контракта известен.
  - Принимает адрес кошелька в формате 0x...
  - Запрашивает баланс $FIL через GLIF SDK.
  - Запрашивает баланс iFIL через вызов контракта ERC20.
  - Возвращает JSON, например: {"fil": "10.0", "ifil": "5.0"}.
  - Ошибки: 500 при сбое запроса к блокчейну, 400 при неверном адресе.
- POST /transaction - отправка транзакции на блокчейн Filecoin (FEVM).
  Предполагаю, что эндпоинт принимает JSON с подписанной транзакцией в hex в поле ~signedTx~. Ее нужно опубликовать через SDK и сохранить в БД (клиент подписывает транзакцию локально, а API только транслирует). я предлагаю принимать JSON с "signedTx", отправителем, получателем, суммой и меткой времени, даже если часть можно извлечь из подписанной транзакции, для простоты. В задаче упоминаются статусы "confirmed"/"failed", так что, вероятно, ожидается обновление статуса. Но это требует мониторинга транзакций, что может быть за пределами задачи.
  Принимает JSON с полями:
  - signedTx (строка HEX подписанной транзакции),
  - sender (адрес отправителя),
  - receiver (адрес получателя),
  - amount (сумма в $FIL, строка или число).
  Отправляет подписанную транзакцию в сеть через GLIF SDK.
  Если отправка успешна, сохраняет детали в базе данных с статусом "pending".
  Возвращает JSON с хешем транзакции, например: {"hash": "0xabc123..."}
- GET /transactions - получение списка транзакций с фильтрацией по адресу отправителя или получателя.
  Поддерживает query-параметры для фильтрации, например:
  - ?sender=0x123... — фильтр по отправителю.
  - ?receiver=0x456... — фильтр по получателю.
  Возвращает список транзакций в формате JSON, например:
  [{"hash": "0xabc...", "sender": "0x123...", "receiver": "0x456...", "amount": "100", "timestamp": "2025-04-09T12:16:00Z", "status": "pending"}]

*** Библиотеки

- Для Filecoin (FEVM) использовать GLIF Pools SDK (специализирован для Filecoin, что может упростить задачу) или go-ethereum (через JSON-RPC).
- Для базы данных выбрать PostgreSQL и, опционально, ORM (например, GORM) или raw SQL (Нужно защититься от SQL-инъекций через параметризацию).
- Для обработки ошибок - middleware для централизованной обработки ошибок, например, Gin (ловит паники и возвращает 500 с описанием ошибки)
- Для логгинга - библиотеку логирования, такую как zap или logrus, для записи ключевых событий:
  Логировать успешные отправки транзакций, ошибки подключения к блокчейну или базе данных. Не логгировать приватники (адреса контрактов можно)

#+BEGIN_EXAMPLE
  log.Info("Transaction submitted", zap.String("hash", txHash))
  log.Error("Failed to connect to blockchain", zap.Error(err))
#+END_EXAMPLE

*** Схема БД

| id        | BIGINT                            | первичный ключ     |
| hash      | VARCHAR                           | хеш транзакции     |
| sender    | VARCHAR                           | адрес отправителя  |
| receiver  | VARCHAR                           | адрес получателя   |
| amount    | DECIMAL                           | сумма              |
| timestamp | TIMESTAMP                         | время              |
| status    | ENUM: (pending confirmed failed). |                    |

Добавить индексы на sender и receiver для быстрого поиска.

*** Тестирование

- Написать unit-тесты для обработчиков и функций базы данных (например, SaveTransaction, GetTransactions).
- Для блокчейна использовать mock-объекты, например, создайте mock-сервер для RPC-запросов.

#+BEGIN_EXAMPLE
  func TestSaveTransaction(t *testing.T) {
      tx := models.Transaction{Hash: "0x123...", Sender: "0x456..."}
      err := database.SaveTransaction(&tx)
      assert.NoError(t, err)
  }
#+END_EXAMPLE

*** Документация

Генерировать README.md в нем:
- Как установить зависимости (go get ...).
- Как настроить базу данных (например, через переменную окружения DATABASE_URL).
- Как подключиться к блокчейну (URL RPC или конфигурация GLIF SDK через переменные окружения).
  - Примеры запросов к API:
    - curl -X GET http://localhost:8080/balance/0x123... → Ожидаемый ответ: {"fil": "10.0", "ifil": "5.0"}.
    - curl -X POST http://localhost:8080/transaction -d '{"signedTx": "0x...", "sender": "0x123...", "receiver": "0x456...", "amount": "100"}' → Ожидаемый ответ: {"hash": "0xabc..."}.
        curl -X GET "http://localhost:8080/transactions?sender=0x123..." → Список транзакций.
- Как запустить миграции базы данных (например, go run main.go migrate).
- Как запустить тесты (go test ./...).

*** Развертывание

- Генерировать необходимые тестовые ключи, скрипты и миграции

*** Файловая структура

- handlers - обработчики API.
- blockchain - взаимодействие с блокчейном (Filecoin через GLIF SDK).
- database - операции с PostgreSQL.
- models - структуры данных, например, для транзакций.

* Возможные траблы

- Баланс iFIL: Если GLIF SDK не поддерживает прямой доступ к iFIL, потребуется дополнительная интеграция с go-ethereum для вызова контракта. Можно использовать переменные окружения для адреса контракта iFIL?
- Подписанные транзакции: Принятие подписанных транзакций от клиента требует проверки их валидности перед отправкой в блокчейн.
- Статус транзакций: Сохранение статуса "pending" без обновления может быть недостаточным для реального сценария. Можно отметить в документации, что в продакшене требуется фоновый процесс для обновления статуса.

* План работ

- Настроить БД, не забыть индексы, написать модели и миграции, генерировать ключи
- Реализовать интеграцию с блокчейном через библиотеки
- Реализовать эндпоинты (возможно фреймворк вроде Gin или Echo для создания RESTful API)
- Реализовать логгинг и прочую обработку ошибок
- Написать тесты
- Докеризовать все это

* Зависимости

в go.mod

#+BEGIN_SRC go :tangle go.mod
  module app

  go 1.20

  require (
      github.com/ethereum/go-ethereum v1.11.5
      github.com/gorilla/mux v1.8.0
      github.com/stretchr/testify v1.10.0
      github.com/testcontainers/testcontainers-go v0.25.0
      go.uber.org/zap v1.24.0
      gorm.io/driver/postgres v1.4.5
      gorm.io/gorm v1.25.5
  )

  require (
      dario.cat/mergo v1.0.1 // indirect
      github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 // indirect
      github.com/Microsoft/go-winio v0.6.2 // indirect
      github.com/StackExchange/wmi v0.0.0-20180116203802-5d049714c4a6 // indirect
      github.com/btcsuite/btcd/btcec/v2 v2.2.0 // indirect
      github.com/cenkalti/backoff/v4 v4.2.1 // indirect
      github.com/cespare/xxhash/v2 v2.3.0 // indirect
      github.com/containerd/log v0.1.0 // indirect
      github.com/containerd/platforms v0.2.1 // indirect
      github.com/cpuguy83/dockercfg v0.3.2 // indirect
      github.com/davecgh/go-spew v1.1.1 // indirect
      github.com/deckarep/golang-set/v2 v2.1.0 // indirect
      github.com/decred/dcrd/dcrec/secp256k1/v4 v4.0.1 // indirect
      github.com/distribution/reference v0.6.0 // indirect
      github.com/docker/docker v28.0.1+incompatible // indirect
      github.com/docker/go-connections v0.5.0 // indirect
      github.com/docker/go-units v0.5.0 // indirect
      github.com/ebitengine/purego v0.8.2 // indirect
      github.com/felixge/httpsnoop v1.0.4 // indirect
      github.com/fsnotify/fsnotify v1.6.0 // indirect
      github.com/go-logr/logr v1.4.2 // indirect
      github.com/go-logr/stdr v1.2.2 // indirect
      github.com/go-ole/go-ole v1.2.6 // indirect
      github.com/go-stack/stack v1.8.1 // indirect
      github.com/gogo/protobuf v1.3.2 // indirect
      github.com/google/uuid v1.6.0 // indirect
      github.com/gorilla/websocket v1.4.2 // indirect
      github.com/grpc-ecosystem/grpc-gateway/v2 v2.24.0 // indirect
      github.com/holiman/uint256 v1.2.0 // indirect
      github.com/jackc/pgpassfile v1.0.0 // indirect
      github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect
      github.com/jackc/pgx/v5 v5.5.4 // indirect
      github.com/jackc/puddle/v2 v2.2.1 // indirect
      github.com/jinzhu/inflection v1.0.0 // indirect
      github.com/jinzhu/now v1.1.5 // indirect
      github.com/klauspost/compress v1.17.4 // indirect
      github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0 // indirect
      github.com/magiconair/properties v1.8.9 // indirect
      github.com/moby/docker-image-spec v1.3.1 // indirect
      github.com/moby/patternmatcher v0.6.0 // indirect
      github.com/moby/sys/sequential v0.5.0 // indirect
      github.com/moby/sys/user v0.1.0 // indirect
      github.com/moby/sys/userns v0.1.0 // indirect
      github.com/moby/term v0.5.0 // indirect
      github.com/morikuni/aec v1.0.0 // indirect
      github.com/opencontainers/go-digest v1.0.0 // indirect
      github.com/opencontainers/image-spec v1.1.1 // indirect
      github.com/pkg/errors v0.9.1 // indirect
      github.com/pmezard/go-difflib v1.0.0 // indirect
      github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c // indirect
      github.com/shirou/gopsutil v3.21.4-0.20210419000835-c7a38de76ee5+incompatible // indirect
      github.com/shirou/gopsutil/v4 v4.25.1 // indirect
      github.com/sirupsen/logrus v1.9.3 // indirect
      github.com/tklauser/go-sysconf v0.3.12 // indirect
      github.com/tklauser/numcpus v0.6.1 // indirect
      github.com/yusufpapurcu/wmi v1.2.4 // indirect
      go.opentelemetry.io/auto/sdk v1.1.0 // indirect
      go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0 // indirect
      go.opentelemetry.io/otel v1.35.0 // indirect
      go.opentelemetry.io/otel/metric v1.35.0 // indirect
      go.opentelemetry.io/otel/sdk v1.32.0 // indirect
      go.opentelemetry.io/otel/trace v1.35.0 // indirect
      go.uber.org/atomic v1.7.0 // indirect
      go.uber.org/multierr v1.6.0 // indirect
      golang.org/x/crypto v0.17.0 // indirect
      golang.org/x/sync v0.11.0 // indirect
      golang.org/x/sys v0.28.0 // indirect
      golang.org/x/text v0.22.0 // indirect
      google.golang.org/grpc v1.70.0 // indirect
      google.golang.org/protobuf v1.36.5 // indirect
      gopkg.in/natefinch/npipe.v2 v2.0.0-20160621034901-c1b8fa8bdcce // indirect
      gopkg.in/yaml.v3 v3.0.1 // indirect
  )
#+END_SRC

* Модель для GORM

#+BEGIN_SRC go :tangle models/Transaction.go
  package models

  import (
      "time"
  )

  type Transaction struct {
      ID        uint64    `gorm:"primaryKey"`
      Hash      string    `gorm:"type:varchar(66);unique"`
      Sender    string    `gorm:"type:varchar(42)"`
      Receiver  string    `gorm:"type:varchar(42)"`
      Amount    float64   `gorm:"type:decimal(30,18)"`
      Timestamp time.Time `gorm:"type:timestamp with time zone"`
      Status    string    `gorm:"type:enum('pending', 'confirmed', 'failed');default:'pending'"`
  }
#+END_SRC

* Скрипт миграции для создания таблицы транзакций

по идее его надо бы генерировать из орга

#+BEGIN_SRC sql :tangle migrations/create_transacts_tbl_.sql.up
  CREATE TABLE transactions (
      id BIGSERIAL PRIMARY KEY,
      hash VARCHAR(66) UNIQUE NOT NULL,
      sender VARCHAR(42) NOT NULL,
      receiver VARCHAR(42) NOT NULL,
      amount DECIMAL(30,18) NOT NULL,
      timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
      status VARCHAR(10) CHECK (status IN ('pending', 'confirmed', 'failed')) DEFAULT 'pending'
  );

  CREATE INDEX idx_transactions_sender ON transactions(sender);
  CREATE INDEX idx_transactions_receiver ON transactions(receiver);
#+END_SRC

* Код для интеграции с блокчейном (вызывается эндпоинтами)

Определение интерфейсов для взаимодействия с блокчейном.

Client: Интерфейс для абстракции GLIF SDK и ERC20-клиента.

#+BEGIN_SRC go :tangle blockchain/types.go
  package blockchain

  import "context"

  // Client defines the interface for blockchain interactions.
  type Client interface {
      GetFILBalance(ctx context.Context, address string) (string, error)
      GetIFILBalance(ctx context.Context, address string) (string, error)
      SubmitTransaction(ctx context.Context, signedTx string) (string, error)
  }
#+END_SRC

Основной код интеграции с блокчейном.

- NewBlockchainClient: Инициализирует клиента с URL RPC и адресом контракта iFIL.
- GetFILBalance: Запрашивает баланс $FIL через GLIF SDK.
- GetIFILBalance: Вызывает метод balanceOf контракта iFIL через go-ethereum.
- SubmitTransaction: Отправляет подписанную транзакцию через GLIF SDK.
- ERC20: Минимальная реализация ERC20-интерфейса для вызова balanceOf. В реальном проекте ABI генерируется через abigen.

#+BEGIN_SRC go :tangle blockchain/blockchain.go
  package blockchain

  import (
      "errors"
      "math/big"
      "strings"

      "github.com/ethereum/go-ethereum/accounts/abi"
      "github.com/ethereum/go-ethereum/accounts/abi/bind"
      "github.com/ethereum/go-ethereum/common"
      "github.com/ethereum/go-ethereum/ethclient"
  )

  type ERC20 struct {
      contract *bind.BoundContract
  }

  func NewERC20(address common.Address, client *ethclient.Client) (*ERC20, error) {
      abiJSON := `[{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"type":"function"}]`

      parsedABI, err := abi.JSON(strings.NewReader(abiJSON))
      if err != nil {
          return nil, err
      }

      contract := bind.NewBoundContract(address, parsedABI, client, client, client)
      return &ERC20{contract: contract}, nil
  }

  func (e *ERC20) BalanceOf(opts *bind.CallOpts, address common.Address) (*big.Int, error) {
      var out []interface{}
      err := e.contract.Call(opts, &out, "balanceOf", address)
      if err != nil {
          return nil, err
      }

      if len(out) != 1 {
          return nil, errors.New("unexpected output from balanceOf")
      }

      balance, ok := out[0].(*big.Int)
      if !ok {
          return nil, errors.New("unexpected type in balanceOf output")
      }

      return balance, nil
  }
#+END_SRC

* Kод для операций с базой

#+BEGIN_SRC go :tangle database/database.go
  package database

  import (
      "gorm.io/gorm"
      "app/models" // ← имя модуля из go.mod + путь к папке
  )

  func SaveTransaction(db *gorm.DB, tx *models.Transaction) error {
      return db.Create(tx).Error
  }

  func GetTransactions(db *gorm.DB) []models.Transaction {
      var transactions []models.Transaction
      db.Find(&transactions)
      return transactions
  }
#+END_SRC

* Код эндпойнтов

GetBalance

    Валидация: Проверяет формат адреса (0x + 40 символов).
    Интеграция с блокчейном: Вызывает GetFILBalance и GetIFILBalance из blockchain.
    Обработка ошибок: Логирует ошибки и возвращает HTTP 500 при сбоях.
    Ответ: Возвращает JSON с балансами $FIL и iFIL.

SubmitTransaction

    Валидация: Проверяет формат signedTx, адресов и положительность суммы.
    Интеграция с блокчейном: Отправляет транзакцию через SubmitTransaction.
    Сохранение: Сохраняет данные в базе через SaveTransaction.
    Обработка ошибок: Логирует и возвращает HTTP 400/500 при ошибках.
    Ответ: Возвращает JSON с хешем транзакции (HTTP 201).

GetTransactions

    Валидация: Проверяет формат фильтров sender и receiver.
    Интеграция с базой данных: Строит запрос с фильтрами и извлекает транзакции.
    Обработка ошибок: Логирует и возвращает HTTP 500 при сбоях.
    Ответ: Возвращает JSON со списком транзакций.

Проверка:

    curl http://localhost:8080/balance/0x1234567890abcdef1234567890abcdef12345678
    curl -X POST -H "Content-Type: application/json" -d '{"signedTx": "0xdeadbeef", "sender": "0x1234567890abcdef1234567890abcdef12345678", "receiver": "0xabcdef1234567890abcdef1234567890abcdef12", "amount": 100}' http://localhost:8080/transaction
    curl "http://localhost:8080/transactions?sender=0x1234567890abcdef1234567890abcdef12345678"

#+BEGIN_SRC go :tangle handlers/handlers.go
  package handlers

  import (
      "encoding/json"
      "net/http"
      "strings"

      "github.com/gorilla/mux"
      "go.uber.org/zap"
      "app/blockchain"
      "app/database"
      "app/models"
  )

  // Handler encapsulates dependencies for HTTP handlers.
  type Handler struct {
      bc     blockchain.Client
      db     *gorm.DB
      logger *zap.Logger
  }

  // NewServer creates a new Handler instance with dependencies.
  func NewServer(bc blockchain.Client, db *gorm.DB, logger *zap.Logger) *Handler {
      return &Handler{
          bc:     bc,
          db:     db,
          logger: logger,
      }
  }

  // GetBalance handles GET /balance/{address} to retrieve FIL and iFIL balances.
  func (s *Server) GetBalance(w http.ResponseWriter, r *http.Request) {
      vars := mux.Vars(r)
      address := vars["address"]
      ctx := r.Context()

      // Валидация адреса
      if !strings.HasPrefix(address, "0x") || len(address) != 42 {
          h.logger.Warn("Invalid address format", zap.String("address", address))
          http.Error(w, "Invalid address format", http.StatusBadRequest)
          return
      }

      // Получение баланса $FIL
      filBalance, err := h.bc.GetFILBalance(ctx, address)
      if err != nil {
          h.logger.Error("Failed to get FIL balance", zap.String("address", address), zap.Error(err))
          http.Error(w, "Failed to get FIL balance", http.StatusInternalServerError)
          return
      }

      // Получение баланса iFIL
      ifilBalance, err := h.bc.GetIFILBalance(ctx, address)
      if err != nil {
          h.logger.Error("Failed to get iFIL balance", zap.String("address", address), zap.Error(err))
          http.Error(w, "Failed to get iFIL balance", http.StatusInternalServerError)
          return
      }

      // Формирование ответа
      response := map[string]string{
          "fil":  filBalance,
          "ifil": ifilBalance,
      }
      w.Header().Set("Content-Type", "application/json")
      if err := json.NewEncoder(w).Encode(response); err != nil {
          h.logger.Error("Failed to encode response", zap.Error(err))
          http.Error(w, "Internal server error", http.StatusInternalServerError)
      }

      h.logger.Info("Balance retrieved", zap.String("address", address), zap.String("fil", filBalance), zap.String("ifil", ifilBalance))
  }

  // SubmitTransaction handles POST /transaction to submit a new transaction.
  func (s *Server) SubmitTransaction(w http.ResponseWriter, r *http.Request) {
      ctx := r.Context()

      // Декодирование запроса
      var req struct {
          SignedTx string  `json:"signedTx"`
          Sender   string  `json:"sender"`
          Receiver string  `json:"receiver"`
          Amount   float64 `json:"amount"`
      }
      if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
          h.logger.Warn("Invalid request body", zap.Error(err))
          http.Error(w, "Invalid request body", http.StatusBadRequest)
          return
      }

      // Валидация входных данных
      if !strings.HasPrefix(req.SignedTx, "0x") || len(req.SignedTx) < 10 {
          h.logger.Warn("Invalid signed transaction format", zap.String("signedTx", req.SignedTx))
          http.Error(w, "Invalid signed transaction format", http.StatusBadRequest)
          return
      }
      if !strings.HasPrefix(req.Sender, "0x") || len(req.Sender) != 42 {
          h.logger.Warn("Invalid sender address", zap.String("sender", req.Sender))
          http.Error(w, "Invalid sender address", http.StatusBadRequest)
          return
      }
      if !strings.HasPrefix(req.Receiver, "0x") || len(req.Receiver) != 42 {
          h.logger.Warn("Invalid receiver address", zap.String("receiver", req.Receiver))
          http.Error(w, "Invalid receiver address", http.StatusBadRequest)
          return
      }
      if req.Amount <= 0 {
          h.logger.Warn("Invalid amount", zap.Float64("amount", req.Amount))
          http.Error(w, "Amount must be positive", http.StatusBadRequest)
          return
      }

      // Отправка транзакции в блокчейн
      txHash, err := h.bc.SubmitTransaction(ctx, req.SignedTx)
      if err != nil {
          h.logger.Error("Failed to submit transaction", zap.String("signedTx", req.SignedTx), zap.Error(err))
          http.Error(w, "Failed to submit transaction", http.StatusInternalServerError)
          return
      }

      // Сохранение транзакции в базе данных
      tx := &models.Transaction{
          Hash:     txHash,
          Sender:   req.Sender,
          Receiver: req.Receiver,
          Amount:   req.Amount,
          Status:   "pending",
      }
      if err := database.SaveTransaction(h.db, tx); err != nil {
          h.logger.Error("Failed to save transaction", zap.String("hash", txHash), zap.Error(err))
          http.Error(w, "Failed to save transaction", http.StatusInternalServerError)
          return
      }

      // Формирование ответа
      response := map[string]string{
          "hash": txHash,
      }
      w.Header().Set("Content-Type", "application/json")
      w.WriteHeader(http.StatusCreated)
      if err := json.NewEncoder(w).Encode(response); err != nil {
          h.logger.Error("Failed to encode response", zap.Error(err))
          http.Error(w, "Internal server error", http.StatusInternalServerError)
      }

      h.logger.Info("Transaction submitted", zap.String("hash", txHash), zap.String("sender", req.Sender), zap.String("receiver", req.Receiver))
  }

  // GetTransactions handles GET /transactions to retrieve transaction records.
  func (s *Server) GetTransactions(w http.ResponseWriter, r *http.Request) {
      ctx := r.Context()
      query := r.URL.Query()

      // Получение фильтров из query-параметров
      sender := query.Get("sender")
      receiver := query.Get("receiver")

      // Валидация фильтров
      if sender != "" && (!strings.HasPrefix(sender, "0x") || len(sender) != 42) {
          h.logger.Warn("Invalid sender filter", zap.String("sender", sender))
          http.Error(w, "Invalid sender filter", http.StatusBadRequest)
          return
      }
      if receiver != "" && (!strings.HasPrefix(receiver, "0x") || len(receiver) != 42) {
          h.logger.Warn("Invalid receiver filter", zap.String("receiver", receiver))
          http.Error(w, "Invalid receiver filter", http.StatusBadRequest)
          return
      }

      // Построение запроса к базе данных
      dbQuery := h.db.WithContext(ctx)
      if sender != "" {
          dbQuery = dbQuery.Where("sender = ?", sender)
      }
      if receiver != "" {
          dbQuery = dbQuery.Where("receiver = ?", receiver)
      }

      // Извлечение транзакций
      var transactions []models.Transaction
      if err := dbQuery.Find(&transactions).Error; err != nil {
          h.logger.Error("Failed to retrieve transactions", zap.Error(err))
          http.Error(w, "Failed to retrieve transactions", http.StatusInternalServerError)
          return
      }

      // Формирование ответа
      w.Header().Set("Content-Type", "application/json")
      if err := json.NewEncoder(w).Encode(transactions); err != nil {
          h.logger.Error("Failed to encode response", zap.Error(err))
          http.Error(w, "Internal server error", http.StatusInternalServerError)
      }

      h.logger.Info("Transactions retrieved", zap.Int("count", len(transactions)), zap.String("sender", sender), zap.String("receiver", receiver))
  }
#+END_SRC

* Main

#+BEGIN_SRC go :tangle main.go
  package main

  import (
      "log"
      "net/http"
      "os"

      "github.com/gorilla/mux"
      "go.uber.org/zap"
      "gorm.io/driver/postgres"
      "gorm.io/gorm"
      "app/blockchain"
      "app/handlers"
  )

  func main() {
      // Инициализация логгера
      logger, _ := zap.NewProduction()
      defer logger.Sync()

      // Подключение к базе данных
      dbURL := os.Getenv("DATABASE_URL")
      db, err := gorm.Open(postgres.Open(dbURL), &gorm.Config{})
      if err != nil {
          logger.Fatal("Failed to connect to database", zap.Error(err))
      }

      // Инициализация клиента блокчейна
      rpcURL := os.Getenv("BLOCKCHAIN_RPC_URL")
      ifilAddress := os.Getenv("IFIL_CONTRACT_ADDRESS")
      bc, err := blockchain.NewBlockchainClient(rpcURL, ifilAddress)
      if err != nil {
          logger.Fatal("Failed to initialize blockchain client", zap.Error(err))
      }

      // Инициализация обработчиков
      h := handlers.NewServer(bc, db, logger)

      // Настройка маршрутов
      r := mux.NewRouter()
      r.HandleFunc("/balance/{address}", h.GetBalance).Methods("GET")
      r.HandleFunc("/transaction", h.SubmitTransaction).Methods("POST")
      r.HandleFunc("/transactions", h.GetTransactions).Methods("GET")

      // Запуск сервера
      port := ":8080"
      logger.Info("Starting server", zap.String("port", port))
      if err := http.ListenAndServe(port, r); err != nil {
          logger.Fatal("Server failed", zap.Error(err))
      }
  }
#+END_SRC

* Файлы тестов

Добавление инструкций по тестированию в README.md

#+BEGIN_SRC markdown :tangle README.md
  # Testing

  The project includes unit and integration tests to ensure correctness of implementation. To run all tests:

  ```sh
  go test ./...


  ## Run tests

  Tests use Testcontainers to create isolated PostgreSQL containers. Make sure Docker is installed and running.

  ### Requirements
  - Docker and Docker Compose
  - Go 1.20 or higher (to run locally)

  ### Running Tests via Docker Compose
  1. Create an `.env` file with environment variables (see `.env.example` for an example).
  2. Run the command:
     ```sh
   docker-compose -f docker-compose.yml run --rm -e TESTCONTAINERS_HOST_OVERRIDE=host.docker.internal app go test ./....
#+END_SRC

Перед тестированием надо настроить все окружение, моки etc

** Тесты для API-обработчиков

с использованием моков для блокчейна и базы данных

- TestGetBalance_Success: Проверяет успешный запрос баланса по адресу, возвращает ожидаемые значения $FIL и iFIL.
- TestGetBalance_InvalidAddress: Проверяет обработку невалидного адреса (HTTP 400).
- TestGetBalance_BlockchainError: Проверяет обработку ошибки при запросе к блокчейну (HTTP 500).
- TestSubmitTransaction_Success: Проверяет успешную отправку транзакции с сохранением в базе.
- TestSubmitTransaction_InvalidData: Проверяет обработку невалидных данных в запросе (HTTP 400).
- TestSubmitTransaction_DatabaseError: Проверяет обработку ошибки при сохранении в базу (HTTP 500).
- TestGetTransactions_Success: Проверяет получение списка транзакций без фильтров.
- TestGetTransactions_WithSenderFilter: Проверяет фильтрацию по отправителю.
- TestGetTransactions_WithReceiverFilter: Проверяет фильтрацию по получателю.
- TestGetTransactions_NoTransactions: Проверяет возврат пустого списка при отсутствии транзакций.

#+BEGIN_SRC go :tangle handlers/handlers_test.go
  package handlers

  import (
      "testing"
      "net/http"
      "net/http/httptest"
  )

  func TestGetBalance_Success(t *testing.T) {
      mockBC := &MockBlockchainClient{
          GetFILBalanceFunc: func(address string) (string, error) {
              return "10.0", nil
          },
          GetIFILBalanceFunc: func(address string) (string, error) {
              return "5.0", nil
          },
      }

      req, _ := http.NewRequest("GET", "/balance/0x123", nil)
      rr := httptest.NewRecorder()
      handler := http.HandlerFunc(handlers.GetBalance(mockBC))
      handler.ServeHTTP(rr, req)

      if status := rr.Code; status != http.StatusOK {
          t.Errorf("handler returned wrong status code: got %v want %v", status, http.StatusOK)
      }

      expected := `{"fil":"10.0","ifil":"5.0"}`
      if rr.Body.String() != expected {
          t.Errorf("handler returned unexpected body: got %v want %v", rr.Body.String(), expected)
      }
  }
#+END_SRC

** Тесты для функций взаимодействия с блокчейном

с использованием моков для GLIF SDK

- TestGetFILBalance_Success: Проверяет успешное получение баланса $FIL.
- TestGetIFILBalance_Success: Проверяет успешное получение баланса iFIL (ERC20-токен).
- TestSubmitTransaction_Success: Проверяет успешную отправку транзакции.

#+BEGIN_SRC go :tangle blockchain/blockchain_test.go
  package blockchain

  import (
      "math/big"
      "testing"

      "github.com/ethereum/go-ethereum/common"
      "github.com/stretchr/testify/assert"
  )

  // MockGLIFClient mocks the GLIF SDK client.
  type MockGLIFClient struct {
      GetBalanceFunc       func(address string) (*big.Int, error)
      SubmitTransactionFunc func(signedTx string) (string, error)
  }

  func (m *MockGLIFClient) GetBalance(address string) (*big.Int, error) {
      return m.GetBalanceFunc(address)
  }

  func (m *MockGLIFClient) SubmitTransaction(signedTx string) (string, error) {
      return m.SubmitTransactionFunc(signedTx)
  }

  // MockEthClient mocks the Ethereum client for iFIL.
  type MockEthClient struct {
      BalanceOfFunc func(address common.Address) (*big.Int, error)
  }

  func (m *MockEthClient) BalanceOf(address common.Address) (*big.Int, error) {
      return m.BalanceOfFunc(address)
  }

  func TestGetFILBalance_Success(t *testing.T) {
      mockGLIF := &MockGLIFClient{
          GetBalanceFunc: func(address string) (*big.Int, error) {
              return big.NewInt(10000000000000000000), nil // 10 FIL
          },
      }
      client := &BlockchainClient{
          glifClient: mockGLIF,
      }

      balance, err := client.GetFILBalance(context.Background(), "0x123")
      assert.NoError(t, err)
      assert.Equal(t, "10000000000000000000", balance)
  }

  func TestGetIFILBalance_Success(t *testing.T) {
      mockEth := &MockEthClient{
          BalanceOfFunc: func(address common.Address) (*big.Int, error) {
              return big.NewInt(5000000000000000000), nil // 5 iFIL
          },
      }
      client := &BlockchainClient{
          ethClient:   nil, // Реальный ethClient не нужен для мока
          ifilAddress: common.HexToAddress("0x456"),
      }
      // Мокаем ERC20 контракт вручную для теста
      client.ethClient = nil // Предполагаем, что это не влияет на тест с моками
      balance, err := client.GetIFILBalance(context.Background(), "0x123")
      assert.NoError(t, err)
      assert.Equal(t, "5000000000000000000", balance)
  }

  func TestSubmitTransaction_Success(t *testing.T) {
      mockGLIF := &MockGLIFClient{
          SubmitTransactionFunc: func(signedTx string) (string, error) {
              return "0xabc123", nil
          },
      }
      client := &BlockchainClient{
          glifClient: mockGLIF,
      }

      txHash, err := client.SubmitTransaction(context.Background(), "0xdeadbeef")
      assert.NoError(t, err)
      assert.Equal(t, "0xabc123", txHash)
  }
#+END_SRC

** Тесты для операций с базой данных

с использованием SQLite в памяти через GORM

- TestSaveTransaction_Success: Проверяет сохранение транзакции.
- TestGetTransactions_Success: Проверяет получение всех транзакций.
- TestGetTransactions_WithSenderFilter: Проверяет фильтрацию по отправителю.
- TestGetTransactions_WithReceiverFilter: Проверяет фильтрацию по получателю.
- TestGetTransactions_NoTransactions: Проверяет возврат пустого списка.

Зависимости
- github.com/testcontainers/testcontainers-go
- github.com/testcontainers/testcontainers-go/modules/postgres

#+BEGIN_SRC go :tangle database/database_test.go
  package database

  import (
      "log"
      "os"
      "testing"

      "github.com/testcontainers/testcontainers-go"
      "gorm.io/driver/postgres"
      "gorm.io/gorm"
  )

  var testDB *gorm.DB

  func TestMain(m *testing.M) {
      ctx := context.Background()
      postgresContainer, err := postgres.Run(ctx,
          testcontainers.WithImage("postgres:16-alpine"),
          postgres.WithDatabase("testdb"),
          postgres.WithUsername("testuser"),
          postgres.WithPassword("testpass"),
      )
      if err != nil {
          log.Fatal(err)
      }
      defer postgresContainer.Terminate(ctx)

      connectionString, err := postgresContainer.ConnectionString(ctx)
      if err != nil {
          log.Fatal(err)
      }

      db, err := gorm.Open(postgres.Open(connectionString), &gorm.Config{})
      if err != nil {
          log.Fatal(err)
      }

      db.AutoMigrate(&models.Transaction{})

      testDB = db

      code := m.Run()

      os.Exit(code)
  }


  func TestSaveTransaction_Success(t *testing.T) {
      tx := &models.Transaction{
          Hash:     "0xabc",
          Sender:   "0x123",
          Receiver: "0x456",
          Amount:   100,
          Status:   "pending",
      }

      err := SaveTransaction(testDB, tx)
      if err != nil {
          t.Errorf("failed to save transaction: %v", err)
      }

      var savedTx models.Transaction
      testDB.First(&savedTx, "hash = ?", "0xabc")
      if savedTx.ID == 0 {
          t.Error("transaction not saved")
      }
  }

  func TestGetTransactions_Success(t *testing.T) {
      // Предварительно сохраняем транзакцию для теста
      tx := &models.Transaction{
          Hash:     "0xabc",
          Sender:   "0x123",
          Receiver: "0x456",
          Amount:   100,
          Status:   "pending",
      }
      testDB.Create(tx)

      transactions := GetTransactions(testDB)
      if len(transactions) == 0 {
          t.Error("expected transactions but got none")
      }
  }
#+END_SRC

* Развертывание

** Скопируйте файл ~.env.example~ в файл ~.env~:

(в корнеой папке проекта)

#+BEGIN_SRC sh
  cp .env.example .env
#+END_SRC

Вот (для возможного редактирования) содержимое файла ~.env.example~:

#+BEGIN_SRC text :tangle .env.example
  POSTGRES_USER=testuser
  POSTGRES_PASSWORD=testpass
  POSTGRES_DB=testdb
  BLOCKCHAIN_RPC_URL=https://api.calibration.node.glif.io/rpc/v0
  IFIL_CONTRACT_ADDRESS=0x1234567890abcdef1234567890abcdef12345678
#+END_SRC

** Соберите и запустите проект через Docker Compose

#+BEGIN_SRC sh
  docker-compose up --build
#+END_SRC

В корневой директории проекта должен лежать файл docker-compose.yml с таким содержимым:

#+BEGIN_SRC text :tangle docker-compose.yml
  version: '3.8'

  services:
    app:
      build:
        context: .
        target: production
      ports:
        - "8080:8080"
      environment:
        - DATABASE_URL=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}?sslmode=disable
        - BLOCKCHAIN_RPC_URL=${BLOCKCHAIN_RPC_URL}
        - IFIL_CONTRACT_ADDRESS=${IFIL_CONTRACT_ADDRESS}
      depends_on:
        db:
          condition: service_healthy

    db:
      image: postgres:16
      environment:
        - POSTGRES_USER=${POSTGRES_USER}
        - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
        - POSTGRES_DB=${POSTGRES_DB}
      volumes:
        - pgdata:/var/lib/postgresql/data
      healthcheck:
        test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
        interval: 10s
        timeout: 5s
        retries: 5

  volumes:
    pgdata:
#+END_SRC

Нужен Docker для запуска тестов БД, так как они требуют изолированного PostgreSQL.

Dockerfile:

#+BEGIN_SRC text :tangle Dockerfile
  # Этап сборки
  FROM golang:1.22-bookworm AS builder
  WORKDIR /app
  COPY go.mod go.sum ./
  RUN go mod download
  COPY . .
  RUN CGO_ENABLED=0 GOOS=linux go build -o main .

  # Этап запуска тестов
  FROM golang:1.22-bookworm AS tester
  WORKDIR /app
  COPY --from=builder /app .
  CMD ["go", "test", "./..."]

  # Этап продакшен
  FROM scratch AS production
  COPY --from=builder /app/main /
  EXPOSE 8080
  CMD ["/main"]
#+END_SRC


Если "docker-compose up --build" отрабатала без ошибок - проект должен подняться и быть доступен по адресу: https://localhost:8080

** Проверьте эндпойнты (например через curl или Postman):

*** Получение баланса:

#+BEGIN_SRC sh
  curl http://localhost:8080/balance/0x1234567890abcdef1234567890abcdef12345678
#+END_SRC

*** Отправка транзакции:

#+BEGIN_SRC sh
  curl -X POST -H "Content-Type: application/json" \
    -d '{
          "signedTx": "0xdeadbeef",
          "sender": "0x1234567890abcdef1234567890abcdef12345678",
          "receiver": "0xabcdef1234567890abcdef1234567890abcdef12",
          "amount": 100
        }' \
    http://localhost:8080/transaction
#+END_SRC

*** Получение истории транзакций:

#+BEGIN_SRC sh
  curl "http://localhost:8080/transactions?sender=0x1234567890abcdef1234567890abcdef12345678"
#+END_SRC
